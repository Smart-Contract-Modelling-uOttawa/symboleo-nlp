Domain propertyRentalDomain
  Landlord isA Role name: String;
  Renter isA Role with name: String;
  Currency isAn Enumeration(CAD, USD, EUR);
  PaymentMethod isAn Enumeration(CHEQUE, CASH, ETRANSFER);
  RentalProperty isAn Asset with address: String;
  Paid isAn Event with amount: Number, currency: Currency, from: Role, to: Role, method: PaymentMethod;
  TakeOccupancy isAn Event with agent: Role;
  BreachAgreement isAn Event with agent: Role;
  ProvideWrittenNotice isAn Event with agent: Role, daysInAdvance: Number;
  Abandons isAn Event with agent: Role, property: RentalProperty;
  Enters isAn Event with agent: Role, property: RentalProperty;
  KeepPets isAn Event with agent: Role, property: RentalProperty;
  ProvidePetPermission isAn Event with grantor: Role;

  # Want to combine all the payment events; but may not be possible.
  # Likely at least need a separate one for paying rent (need a frequency...)
endDomain

Contract PropertyRental( landlord: Landlord, renter: Renter, ...)

# Do all events need to be declared in the Declarations?
# In theory, should be able to create it right within an obligation...
Declarations
  the_property: RentalProperty with address := _address;
  evt_pay_rent: Paid with amount := _rent_amount, currency = _currency, from := _renter, to := _landlord, method := _payment_method;
  evt_pay_late_fine: Paid with amount := _late_fine, currency = _currency, from := _renter, to := _landlord, method := _payment_method;
  evt_pay_deposit: Paid with amount := _security_amount, currency = _currency, from := _renter, to := _landlord, method := _payment_method;
  evt_return_deposit: Paid with amount := _security_amount, currency = _currency, from := _landlord, to := _renter, method := _payment_method
  evt_take_occupancy: TakeOccupancy with agent := _renter; 
  evt_renter_breach: BreachAgreement with agent := _renter;
  evt_landlord_breach: BreachAgreement with agent := _landlord;
  evt_provides_written_notice: ProvideWrittenNotice with agent := _renter, daysInAdvance := _daysInAdvance;
  evt_abandons: Abandons with agent: _renter, property := the_property;
  evt_enters: Enters with agent: _landlord, property := the_property;
  evt_keep_pets: KeepPets with agent: _renter;
  evt_provide_pet_permission: ProvidePetPermission with grantor: _landlord;

Preconditions
  ...

Postconditions
  I...

Obligations
  pay_initial: Obligation(renter, landlord, true, Happens(evt_pay_initial));
  pay_rent: **Frequency...
  late_payment: Happens(Violated(obligations.pay_rent)) -> Obligation(renter, landlord, true, Happens(evt_pay_late_fine)); 
  pay_security_deposit: Obligation(renter, landlord, true, HappensBefore(evt_pay_deposit, evt_take_occupancy));
  return_deposit: Happens(Terminated(self)) -> Obligation(landlord, renter, true, Happens(evt_return_deposit));
  ## May have antecedent for keeping in good condition (evt_ruin_apartment)
  
  no_pets: Obligation(renter, landlord, true, not Happens(evt_keep_pets));

Surviving Obligations
  ...


Powers
  terminate_breach1: Happens(evt_renter_breach) -> Power(landlord, renter, true, Terminated(self));
  terminate_breach2: Happens(evt_landlord_breach) -> Power(renter, landlord, true, Terminated(self));
  terminate_notice1: Happens(evt_provides_written_notice) -> Power(renter, landlord, true, Terminated(self));
  # Could have terminate_notice2...
  allow_pets: Happens(evt_provide_pet_permission) -> Power(renter, landlord, true, Suspend(obligations.no_pets))
  ## This would be a good use case of the unless... adding a norm
  ## This would also be where we want to allow the user to input th event 
  ## Should assume that the "provide permission" event isnt in the domain model 
  ## Good challenge...
  

Constraints
  ...

endContract